<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: dataAcquisition/fetchHelper.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: dataAcquisition/fetchHelper.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** Perform a petch on a firebrowse endpoint. This function is not meant to be used
 * on its own. Please use `fetchFromFireBrowse`.
 *
 * @param {string} endpoint - FireBrowse endpoint to use.
 * @param {object} params - Parameters to the query.
 * @param {string} expectedKey - The key that is expected in the returned object.
 * @returns {Promise&lt;Object.&lt;string, Array>>} Fetched data.
 */
const _fetchFromFireBrowse = async function(endpoint, params, expectedKey) {
  const base = "https://firebrowse.herokuapp.com";
  // Remove a leading / in the endpoint so we don't have duplicate / in
  // the url. Using // in a url is valid but it feels dirty.
  if (endpoint.startsWith("/")) {
    endpoint = endpoint.substring(1);
  }
  endpoint = `http://firebrowse.org/api/v1/${endpoint}`;
  params = new URLSearchParams(params);
  const url = `${base}?${endpoint}?${params.toString()}`;

  const minimalJson = { [expectedKey]: [] };

  const response = await fetch(url);
  if (!response.ok) {
    console.error(`Fetching ${expectedKey} data was unsuccessful.`);
    return minimalJson;
  }
  const json = await response.json();
  if (!json) {
    console.log(`${expectedKey} is empty, returning an object with empty ${expectedKey} `);
    return minimalJson;
  }
  return json;
};


/** Make a deep clone of an object.
 *
 * @template T
 * @param {T} obj - Object to clone.
 * @returns {T} Deeply cloned object.
 */
const _deepClone = function(obj) {
  return JSON.parse(JSON.stringify(obj));
};


/** Transform object of parameters to a list of grouped parameters.
 *
 * @param {Object.&lt;string, any>} params - Parameters.
 * @param {Array.&lt;{key: string, length: number}>} groupBy - Groupby info.
 *
 * @returns {Array.&lt;Object.&lt;string, any>>} Array of parameters.
 *
 * @example
 * const params = {
 *  "foo": ["a", "b", "c", "d"],
 *  "bar": ["w", "x", "y", "z"],
 *  "cat": "dog",
 * };
 * const groupBy = [{key: "foo", length: 4}, {key: "bar", length: 3}];
 * _paramsToParamsMatrix(params, groupBy);
 * // [{
 * //   bar: ["w", "x", "y"],
 * //   cat: "dog",
 * //   foo: ["a", "b", "c", "d"]
 * //  }, {
 * //   bar: ["z"],
 * //   cat: "dog",
 * //   foo: ["a", "b", "c", "d"]
 * //  }]
 */
const _paramsToParamsMatrix = function(params, groupBy) {

  const newParams = [];

  const addSlices = (slices) => {
    // Copy params so we can keep the data we are not grouping by, and then update
    // with the sliced objects.
    let paramsCopy = _deepClone(params);
    paramsCopy = Object.assign(paramsCopy, slices);
    newParams.push(paramsCopy);
  };

  if (groupBy.length === 1) {
    const groupByA = groupBy[0];
    for (let i=0; i&lt;params[groupByA.key].length; i+=groupByA.length) {
      const slicedObject = {
        [groupByA.key]: params[groupByA.key].slice(i, i+groupByA.length),
      };
      addSlices(slicedObject);
    }
  } else if (groupBy.length === 2) {
    const groupByA = groupBy[0], groupByB = groupBy[1];
    for (let i=0; i&lt;params[groupByA.key].length; i+=groupByA.length) {
      for (let j=0; j&lt;params[groupByB.key].length; j+=groupByB.length) {
        const slicedObject = {
          [groupByA.key]: params[groupByA.key].slice(i, i+groupByA.length),
          [groupByB.key]: params[groupByB.key].slice(j, j+groupByB.length),
        };
        addSlices(slicedObject);
      }
    }
  } else if (groupBy.length === 3) {
    const groupByA = groupBy[0], groupByB = groupBy[1], groupByC = groupBy[2];
    for (let i=0; i&lt;params[groupByA.key].length; i+=groupByA.length) {
      for (let j=0; j&lt;params[groupByB.key].length; j+=groupByB.length) {
        for (let k=0; k&lt;params[groupByC.key].length; k+=groupByC.length) {
          const slicedObject = {
            [groupByA.key]: params[groupByA.key].slice(i, i+groupByA.length),
            [groupByB.key]: params[groupByB.key].slice(j, j+groupByB.length),
            [groupByC.key]: params[groupByC.key].slice(k, k+groupByC.length),
          };
          addSlices(slicedObject);
        }
      }
    }
  } else {
    console.error("too many groupBy objects");
  }
  return newParams;
};


/** Perform a fetch from the FireBrowse API.
 *
 * @param {string} endpoint - API endpoint to query.
 * @param {Object.&lt;string, any>} params - Parameters of the query.
 * @param {Array.&lt;{key: string, length: number}>} [groupBy] - Groupby info.
 *
 * @returns {Promise&lt;Object.&lt;string, Array>>} Fetched data.
 *
 * @example
 *  await fetchFromFireBrowse("/Samples/mRNASeq", {
 *      format: "json",
 *      gene: geneQuery,
 *      cohort: cohortQuery,
 *      protocol: "RSEM",
 *      page: "1",
 *      page_size: 2001,
 *      sort_by: "tcga_participant_barcode",
 *    });
 */
const fetchFromFireBrowse = async function(endpoint, params, groupBy) {
  // We could use Array.at(-1) to get the last item, but that does not have broad
  // browser support at this time.
  const splits = endpoint.split("/");
  const expectedKey = splits[splits.length - 1];

  if (groupBy == null) {
    return await _fetchFromFireBrowse(endpoint, params, expectedKey);
  } else {
    const results = {[expectedKey]: []};
    const paramsMatrix = _paramsToParamsMatrix(params, groupBy);
    /** @type {Array.&lt;Promise&lt;number>>} */
    const calls = [];
    for (let i=0; i&lt;paramsMatrix.length; i++) {
      const paramsForThisCall = paramsMatrix[i];
      // Run a fetch and then collect the data into one common object.
      const call = _fetchFromFireBrowse(endpoint, paramsForThisCall, expectedKey)
        .then(x => results[expectedKey].push(...x[expectedKey]));
      calls.push(call);
    }
    await Promise.all(calls);
    return results;
  }
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#_deepClone">_deepClone</a></li><li><a href="global.html#_fetchFromFireBrowse">_fetchFromFireBrowse</a></li><li><a href="global.html#_paramsToParamsMatrix">_paramsToParamsMatrix</a></li><li><a href="global.html#fetchClinicalFH">fetchClinicalFH</a></li><li><a href="global.html#fetchFromFireBrowse">fetchFromFireBrowse</a></li><li><a href="global.html#fetchmRNASeq">fetchmRNASeq</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Sun Oct 31 2021 20:39:23 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
